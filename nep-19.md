<pre>
  NEP: 19
  Title: Neo N3 Contract Debug Info Specification
  Author: Harry Pierson (harrypierson@hotmail.com)
  Type: Standard
  Status: 
    Version 1: Accepted
    Version 2: Draft
  Created: 2019-09-02
</pre>

# Neo N3 Contract Debug Info Specification

## Abstract

This NEP describes the debug information format used by the 
[Neo Smart Contract Debugger](https://github.com/neo-project/neo-debugger).
This information is generated by smart contract compilers such as 
[NCCS](https://github.com/neo-project/neo-devpack-dotnet)
and [neo-boa](https://github.com/CityOfZion/neo-boa).

## Motivation

In order to provide a good developer experience, the debugger needs additional type information
about parameters, variables and storage items that exists in the contract source code but is not
needed by the NeoVM and is discarded during contract compilation. The debugger also needs to source
map information in order to map binary addresses in compiled contracts to locations in source code.

### Version 2 Motivation

About six months after Neo N3 MainNet shipped, the debugger shipped a preview feature called 
[Storage Schema](https://github.com/neo-project/neo-debugger/blob/master/docs/storage-schema-overview.md).
Storage Schema improves the developer experience by automatically decoding the contents of contract
storage keys and items.

In order to decode storage keys and items, the debugger needs type information about contract
storage. For the initial preview release, this type information lives in a separate JSON file
that is written by hand. Obviously, forcing the developer to maintain a separate file is less than
ideal, so work started on upgrading the NCCS compiler to emit storage schema information automatically
from source code.

As part of this work, a model for storage type information was created. While the runtime types
were limited to type information that can be encoded as a
[ContractParameterType](https://github.com/neo-project/neo/blob/master/src/neo/SmartContract/ContractParameterType.cs),
the storage type model could encode additional type information such as the fields of a structure,
the type of a homogeneous collection or the key and value types of a map.

It turned out to be trivial to extend the storage type information model to also support runtime
types. Futhermore, it turned out to be straightforward to generate this additional type information
for runtime types during compilation in the NCCS compiler. As such, the type information model was
renamed as the "contract type information model" and the NCCS compiler was further updated to generate
this unified type information for both runtime and storage types.

While maintaining mostly the same structure, the string encoding of this new type model forces version
2 of the debug info format to break backwards compatibility with version 1. As such, the updated format
includes a `version` property so that the debugger can correctly interpret string encoded type information.
Of course, the debugger supports both v1 and v2 debug information, enabling programming language teams
to move to the new format in a time frame of their own choosing. There are no plans to remove support
for v1 debug information, so programming language teams don't have to update their compilers at all
if they so choose.

> Note, generating richer contract type model in NCCS is straightforward in part because of the rich type
  information available in C#. Supporting some aspects of the new contract type model may be more difficult
  or impossible in Neo compilers for dynamic lanugages such as Python. The v2 format has been designed
  with such language limitations in mind. However, the contract type model is expected to evolve based
  on feedback from Neo compiler teams as they upgrade their compilers to enable the new debugger functionality.

## Rationale

Version 1 of this format has been implemented by the Neo Smart Contract Debugger and multiple Neo smart contract
compilers including NCCS, NEON, neo-boa, Neow3j and neo-go.

Version 2 of this format enables an improved variable inspection experience and supports both runtime and
storage types.

## Debug Info Format Specification

Neo compilers SHOULD emit debug information as part of the compilation process along with the required
compiled contract binary and contract manifest. Emitting debug information is optional, but the Neo
Smart Contract Debugger will be limited to disassembly level debugging without it.

Debug info is stored in JSON format, described informally below and specified via the
[neo-debug-info.schema.json](./nep-debuginfo/neo-debug-info.schema.json) file.
The debug info is stored in a file with the same base name as the contract binary with the extension
`.debug.json`. The debug info can be optionally compressed using standard Zip compression. When compressed,
the debug info archive must have single `.debug.json` file and the archive itself must have an `.nefdbgnfo`
extension. 

> Note, the format is defined in this specification using TypeScript for readability. There is no requirement
  that this format be implemented in TypeScript. The full specification of this format is specified in
  [neo-debug-info.schema.json](./nep-debuginfo/neo-debug-info.schema.json).

The debug info has the following structure. Note, for space optimization, several string properties contain
multiple pieces of information encoded as a string. Those encodings are indicated in comments in the code below.

``` ts
type EncodedType = string; // format: For v1, this is a ContractParamterType enum value
                           //         For v2, this is a string encoded ContractType. Details below
type MemberName = string   // format: "{namespace},{display-name}
type Variable = string;    // format: "{name},{EncodedType}(,{slotIndex})?

interface Method {
    id?: string; // id field no longer needed, may be omitted in v2
    name: MemberName; 
    range: string; // format: "{start-address}-{end-address}
    params?: Variable[]; 
    return?: EncodedType | "#Void"; // #Void only allowed in v2
    variables?: Variable[]; 
    "sequence-points"?: string[]; // format: "{address}[{document-index}]{start-line}:{start-column}-{end-line}:{end-column}"
}

interface Event {
    id?: string; // id field no longer needed, may be omitted in v2
    name: MemberName; 
    params?: Variable[]; 
}

// top level debug info properties from v1 of the specification
interface DebugInformation {
    hash: string; // hex-encoded UInt160
    documents?: string[]; // file paths
    events?: Event[];
    methods?: Method[];
    "static-variables"?: Variable[]; 
}

// Structs only supported in v2
interface Struct {
    name: MemberName;
    fields?: string[]; // format: "{name},{string encoded ContractType}"
}

// StorageGroups only supported in v2
interface StorageGroup {
    name: MemberName;
    type: EncodedType; // Must be string encoded ContractType
    prefix: string; // format: hex-encoded byte array
    segments?: string[]; // format: "{name},{string encoded ContractType}"
}

// top level debug info properties added in v2 of the specification
interface DebugInfoV2 : DebugInformation {
    version: number;
    checksum: number;
    structs?: Struct[];
    storages?: StorageGroup[];
}
```

### EncodedType

TBD

### Version 1 Type Model

EncodedTypes in Neo debug info are string encoded values from the 
[ContractParameterType enum type](https://github.com/neo-project/neo/blob/master/src/neo/SmartContract/ContractParameterType.cs)

* Any
* Boolean
* Integer
* ByteArray
* String
* Hash160
* Hash256
* PublicKey
* Signature
* Array
* Map
* InteropInterface
* Void

Generally, this type information is used to decode NeoVM types during debugging. For example, NeoVM has no
native string type - strings are represented in NeoVM as a [ByteString](https://github.com/neo-project/neo-vm/blob/master/src/neo-vm/Types/ByteString.cs).
The additional type information enables the debugger to treat the bytes in the NeoVM ByteString as a UTF-8
encoded string in order to decode the string for the developer.

### Variable

Variable types are used to encode name and type information about NeoVM arguments, local variables and static
fields. Additionally, a variable may include an optional slot index. This is useful for scenarios where the
compiler may use slots for hidden variables not authored by the developer. If the slot index is not specified,
the array index of the Variable type is used as the slot index. For a given variable array, *ALL* variables *MUST*
include a slot index if *ANY* variables contain a slot index. Mixing variables with and and without an optional
slot index in a single Variable array is *NOT SUPPORTED*. It is supported to have some Variable arrays include
slot index information while other Variable arrays in the same debug info file do not.

Name, type and optional slot index are combined into a single comma separated string. A Variable without slot
index has a single comma (i.e. `varName,varType`) while a Variable with index has two commas (i.e. `varName,varType,1`).

### MemberName

MemberName types are used to store the name and optional namespace of a type member such as a method or event.
MemberName namespace is optional, but the comma separator is not. For encoding members with no namespace, the
MemberName string MUST start with a comma (i.e. `',SomeName'`).

### Method

Method types have the following properties:

* `name`: a MemberName with the method's name and optional namespace
* `range`: the range of NeoVM script addresses that is associated with this method. 
  Range is encoded as a string with the start and end addresses as integers separated by a dash
* `params`: a collection of Variable instances representing the NeoVM arguments associated with this
  method
* `return`: the EncodedType method's return value or `#Void`
* `variables`: a collection of Variable instances representing the NeoVM local variables associated
  with this method
* `sequence-points`: a collection of strings that encode a map of NeoVM script addresses back to
  source code locations.

While the v1 ContractParameterType model has a `Void` value, the v2 ContractType model purposefully
lacks a mechanism to encode the `void` type. While many programming languages do support a general
use `void` or `unit` type, Neo contracts only support `void` as a method return type. As such, void
return methods in a v2 debug info file may specify `#Void` as their `return` property value, even
though that is not a legal encoded ContractType as described above. `#Void` cannot be specified
for any other EncodedType except method `return` properties in a v2 debug info file.

Note, `params`, `return`, `variables` and `sequence-points` properties are all optional. A Method object
with no `return` property will default to having no return value (aka void return). A Method object
with no `params`, `variables` or `sequence-points` properties will default to having an empty array
of the collection in question.

A sequence point contains six integers encoded into a single string

* `address`: This is an integer representing the location in the contract script of the sequence point.
* `document-index`: This is an index into the `documents` array indicating the source code file 
  containing the sequence point. `documents` array is described below.
* `start-line`: This is the line in the source code file that is associated with the sequence point
* `start-column`: This is the column of the line specified above in the source code file associated with
  the sequence point. Note, this value can be zero for languages that don't support mapping sequence points
  to segments within a line
* `end-line`: for languages that support multi-line code expressions, this is the last line of the source
  code associated with the sequence point. For single-line expressions, this will be the same as `start-line`
* `end-column`: for languages that support multi-line code expressions, this is column within `end-line`
  that marks the end of the sequence point code expression. Like `start-column`, it can be zero. Sequence
  points that have the same start/end line and zero for both start/end column will render the sequence
  point as the full line specified.

The six integers of a single sequence point are string encoded using this pattern:

`{address}[{document-index}]{start-line}:{start-column}-{end-line}:{end-column}`

### Event

Event types have the following properties:

* `name`: a MemberName with the method's name and optional namespace
* `params`: a collection of Variable instances representing the NeoVM arguments associated with this event

Note, like Method types, `params` is optional. An event object with no `params` property will default to an
empty `params` array.

### Struct

Struct types have the following properties

* `name`: a MemberName with the struct's name and optional namespace
* `fields`: a collection of strings containing each field's name and string encoded ContractType. 
  Basically the same as a Variable without any slot index info.

Because Structs are a v2 feature, the field type MUST be a string encoded ContractType rather
than a ContractParamterType.

Note, `fields` is optional. A struct object with no `fields` property will default to an
empty `fields` array.

### StorageGroup

StorageGroup types have the following properties

* `name`: a MemberName with the storage group's name and optional namespace
* `type`: the string encoded ContractType
* `prefix`: a hex-encoded byte array of the hard coded prefix for all keys in this group
* `segments`: a collection of strings containing each fields name and string encoded ContractType.
  Similar to a Variable without slot index info, except that the ContractType must be a primitive type.

Because StorageGroups are a v2 feature, the storage group type and each segment type MUST be a string
encoded ContractType. Furthermore, segment types SHOULD be *PRIMITIVE* Contract Types and each segment
except for the last segment SHOULD be a fixed size (Address, Hash160, Hash256, PublicKey and Signature).
The debugger does not support non primitive keys or variable-length segments that precede other segments.
In those cases, the debugger will simply default to a single key segment with primitive ByteArray type.

Note, `segments` is optional. A StorageGroup object with no `segments` property will default to an
empty `segments` array.

### DebugInformation

Top level debug information has the following properties

#### `version`

> Note, this property was added in v2

This property stores an integer representing the version of the format a given debug info file is using.
This value MUST be `1` or `2`. If omitted, this property defaults to version `1`.
 
#### `hash`

This property stores the UInt160 hash value of the contract's `Script`. Note, this is *NOT* the same as a
deployed contract's script hash. The debugger uses this hash value to map deployed contracts to their
debug information. The hash value is stored as a hex encoded string with an optional "0x" prefix.

#### `checksum`

> Note, this property was added in v2.

This property stores the contract's NEF file checksum value. This field is required for version 2 and
later debug info documents. 

#### `documents`

This property stores an array of file paths, used in sequence point data. These paths should be full file
paths as they existed on the machine where the contract was compiled. Neo Smart Contract Debugger has 
the ability to automatically discover differences in paths between compiling and debugging machine, 
plus supports manual source file mapping for cases where the mapping cannot be determined automatically.
If omitted, this property defaults to an empty array.

#### `static-variables`

This property stores an array of Variable types, representing the static fields associated with this contract.
If omitted, this property defaults to an empty array.

#### `methods`

This property stores an array of Method types as described above. Each Method object represents a method in the
contract. Both private and public methods from the contract should be represented in the `methods` array.
If omitted, this property defaults to an empty array.

#### `events`

This property stores an array of Event types as described above. Each Event object represents a parameters
of a contract notification that may be fired during contract execution. If omitted, this property defaults
to an empty array.

#### `structs`

> Note, this property was added in v2.

This property stores an array of Struct types as described above. Each Struct object represents a
heterogeneous collection of named fields, each with a specified type. These structs may be used both
runtime NeoVM types as well as serialized storage types. If omitted, this property defaults to an
empty array.

#### `storageGroups`

> Note, this property was added in v2.

This property stores an array of StorageGroup types as described above. Each StorageGroup object
represents a prefixed collection of one or more storage key/items. These storageGroups are used
to decode contract storage for the debugger. If omitted, this property defaults to an empty array.

## Backwards Compatibility

> Note, as described above, type encoding for v2 debug information is not backwards compatible
  with v1 debug information. This section describes backwards compatibility with Neo debug
  formats prior to the v1 version of this NEP.

Initial preview releases of the Neo Smart Contract Debugger for Neo Legacy used a more verbose
format for debug info. That format was incompatible with the format described in this document,
but never shipped in a production release. Production releases of the Neo Legacy debugger use a
slightly different version of the format described in this document.

The Neo N3 Debugger initially shipped during preview without the DebugInformation `static-variables`
property or the `slotIndex` Variable value. These were added as optional fields before production
release of the N3 Debugger. 

Details regarding older versions of the debug info format is available in the 
[original Design Note](https://github.com/ngdenterprise/design-notes/blob/master/NDX-DN11%20-%20NEO%20Debug%20Info%20Specification.md).
